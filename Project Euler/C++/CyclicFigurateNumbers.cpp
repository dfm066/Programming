/*
 * Cyclical figurate numbers
 *   
 * Problem 61
 * 
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 * are all figurate (polygonal) numbers and are generated by the following formulae:
 * Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
 * Square 	  	    P4,n=n2 	  	    1, 4, 9, 16, 25, ...
 * Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
 * Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
 * Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
 * Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...
 * 
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 * 
 * The set is cyclic, in that the last two digits of each number is the first two digits of
 *  the next number (including the last number with the first).
 * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
 *  is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.
 * 
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
 *  triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 * 
 */
#include "utils.h"

template <Integer I>
I TriangleNumber(I n)
{
    return n * (n + 1) / 2;
}
template <Integer I>
I SquareNumber(I n)
{
    return n * n;
}
template <Integer I>
I PentagonalNumber(I n)
{
    return n * (3 * n - 1) / 2;
}
template <Integer I>
I HexagonalNumber(I n)
{
    return n * (2 * n - 1);
}
template <Integer I>
I HeptagonalNumber(I n)
{
    return n * (5 * n - 3) / 2;
}
template <Integer I>
I OctagonalNumber(I n)
{
    return n * (3 * n - 2);
}

double solveQuadraticEq(double a, double b, double c)
{
    // solve for ax^2 + bx + c = 0
    double first = (-b + std::sqrt(b*b - 4*a*c))/(2*a);
    double second = (-b - std::sqrt(b*b - 4*a*c))/(2*a);
    return std::ceil(std::max(first, second));
}
template <Integer I>
I InvTriangleNumber(I n)
{
    // solve for 0.5x^2 + 0.5x - x = 0
    double a = 0.5, b = 0.5, c = -n;
    return I(solveQuadraticEq(a,b,c));
}
template <Integer I>
I InvSquareNumber(I n)
{
    // solve for x^2 - n = 0
    return I(ceil(sqrt(double(n))));
}
template <Integer I>
I InvPentagonalNumber(I n)
{
    // solve for 1.5x^2 - 0.5x - x = 0
    double a = 1.5, b = -0.5, c = -n;
    return I(solveQuadraticEq(a,b,c));
}
template <Integer I>
I InvHexagonalNumber(I n)
{
    // solve for 2x^2 - 1x - n = 0
    double a = 2, b = -1, c = -n;
    return I(solveQuadraticEq(a,b,c));
}
template <Integer I>
I InvHeptagonalNumber(I n)
{
    // solve for 2.5x^2 - 1.5x - n = 0
    double a = 2.5, b = -1.5, c = -n;
    return I(solveQuadraticEq(a,b,c));
}
template <Integer I>
I InvOctagonalNumber(I n)
{
    // solve for 3x^2 - 2x - n = 0
    double a = 3, b = -2, c = -n;
    return I(solveQuadraticEq(a,b,c));
}


// Find ordered set of six cyclic 4-digit numbers
bool solution61(const std::vector<std::pair<int, int>> *startCycle, std::unordered_set<int> *cycle,
        int firstUsed, int use, int *curr_used)
{
    // Check if we have set of six numbers
    if (std::count(curr_used+3, curr_used+9, 1) == 6) {
        // Check if sixth number is completeing cycle.
        if (use%100 == firstUsed/100) {
            return true;
        }
        return false;
    }

    // Pick next number starting from end part of currently used number
    for (const auto& candidate : startCycle[use%100]) {
        if (curr_used[candidate.second] || cycle->count(candidate.first)) continue;
        else {
            // Guess candidate as valid cyclic polygonal number.
            curr_used[candidate.second] = 1;
            cycle->insert(candidate.first);
            if (solution61(startCycle, cycle, firstUsed, candidate.first, curr_used)) {
                // Guess is correct
                return true;
            }
            // Guess is incorrect so restore the curr_used and cycle
            curr_used[candidate.second] = 0;
            cycle->erase(candidate.first);
        }
    }
    
    // Failed to find any solution for given parameters.
    return false;
}

int main()
{
    using namespace std;
    auto st_t = GET_HRTIME();
    // Initialize maps with polygonal number generators and inverse polygonal number generators.
    // polygonalNumGenerator contains "|vertices of polygon|" : "polygon number generator"
    // invPolygonalNumGenerator contains "|vertices of polygon|" : "inverse polygon number generator"
    unordered_map<int, int (*)(int)> polygonalNumGenerator;
    unordered_map<int, int (*)(int)> invPolygonalNumGenerator;
    {
        polygonalNumGenerator[3] = TriangleNumber;
        polygonalNumGenerator[4] = SquareNumber;
        polygonalNumGenerator[5] = PentagonalNumber;
        polygonalNumGenerator[6] = HexagonalNumber;
        polygonalNumGenerator[7] = HeptagonalNumber;
        polygonalNumGenerator[8] = OctagonalNumber;
        invPolygonalNumGenerator[3] = InvTriangleNumber;
        invPolygonalNumGenerator[4] = InvSquareNumber;
        invPolygonalNumGenerator[5] = InvPentagonalNumber;
        invPolygonalNumGenerator[6] = InvHexagonalNumber;
        invPolygonalNumGenerator[7] = InvHeptagonalNumber;
        invPolygonalNumGenerator[8] = InvOctagonalNumber;
    }

    // Generated 4-digit polygonal numbers
    vector<int> polygonalNumbers[9];
    // Vector containing <polygonal number, vertices> pair starting with index digits.
    vector<pair<int, int>> startCycle[100];
    // Start consider range [1000..9999]
    int st = 1000, en = 9999;
    // Generate 4-digit polygonal numbers for vertices [3..8]
    for (int vertices = 3; vertices < 9; vertices++) {
        auto n = invPolygonalNumGenerator[vertices](st);
        auto first = polygonalNumGenerator[vertices](n);
        while (first <= en) {
            // Add <polygonal number, vertices> pair starting with number/100
            startCycle[first/100].push_back(make_pair(first, vertices));
            polygonalNumbers[vertices].push_back(first);
            first = polygonalNumGenerator[vertices](++n);
        }
    }

    int sum = 0;
    int used_polygon[9];
    unordered_set<int> cyclicNumbers;
    // Find ordered set of six cyclic 4-digit numbers.
    for (const auto& candidate : polygonalNumbers[3]) {
        // init helper structures
        memset(used_polygon, 0, 9 * sizeof(int));
        cyclicNumbers.clear();

        // Start a guess from triangular number
        used_polygon[3] = 1;
        cyclicNumbers.insert(candidate);
        
        // Check if guess is right.
        if (solution61(startCycle, &cyclicNumbers, candidate, candidate, used_polygon)) {
            sum = std::accumulate(std::begin(cyclicNumbers), std::end(cyclicNumbers), 0);
            cout << "Ordered set of six cyclic 4-digit polygonal numbers : (";
            for (const auto& cycle : cyclicNumbers) cout << cycle << " + ";
            cout << "\b\b\b) " << endl;
            break;
        }
    }
    auto en_t = GET_HRTIME();
    time_diff exec_t = en_t - st_t;
    cout << "Solution : " << sum << endl;
    cout << "Time to execute : " << ms(exec_t).count() << "ms\t" 
       << us(exec_t).count() << "us\t" << ns(exec_t).count() << "ns\n" <<  endl;
    if (!sum) cout << "No solution found !!!!" << endl;
    return 0;
}